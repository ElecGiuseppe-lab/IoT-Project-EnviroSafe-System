#include <SoftwareSerial.h>

#define SOP '<'
#define EOP '>'
#define MAX_LENGTH 18 // Lunghezza massima del pacchetto, puÃ² essere aumentata se necessario
#define Tens_Pin A3

SoftwareSerial mySerial(10,11); // RX, TX

void setup() {
  Serial.begin(9600);
  mySerial.begin(9600);
}

void loop() {
  // Flag per inizio e fine pacchetto
  bool started = false;
  bool ended = false;
  
  uint8_t inData[MAX_LENGTH];
  byte index = 0;
  byte Transmit_Data[2];
  uint8_t packetLength = 0; // Variabile per memorizzare la lunghezza del pacchetto (byte di dati)
  uint16_t Tensione;

uint8_t previousPacketLength = 0;

while (mySerial.available() > 0) {
    uint8_t inChar = mySerial.read();
    Serial.print("Carattere ricevuto: ");
    Serial.println(inChar, HEX);

    if (inChar == SOP) {
        index = 0;
        started = true;
        ended = false;
        Serial.println("Inizio pacchetto rilevato.");
    } else if (inChar == EOP) {
        ended = true;
        Serial.println("Fine pacchetto rilevata.");
        break;
    } else {
        if (started) {
            if (index == 0) {
                packetLength = inChar;
                if (packetLength != previousPacketLength) {
                    Serial.print("ATTENZIONE: Modifica inattesa della lunghezza del pacchetto! Lunghezza precedente: ");
                    Serial.print(previousPacketLength);
                    Serial.print(", nuova lunghezza: ");
                    Serial.println(packetLength);
                }
                previousPacketLength = packetLength;
                Serial.print("Lunghezza del pacchetto impostata a: ");
                Serial.println(packetLength);
            } else if (index < packetLength + 1 && index < MAX_LENGTH) {
                inData[index - 1] = inChar;
                Serial.print("Byte aggiunto a inData[");
                Serial.print(index - 1);
                Serial.print("]: ");
                Serial.println(inChar, HEX);
            }
            index++;
        }
    }
    Serial.print("Valore corrente di packetLength: ");
    Serial.println(packetLength);
}

if (started && ended && index == packetLength + 1) {
    // Stampa il contenuto di inData
    Serial.println("Contenuto di inData dopo la ricezione:");
    for (int i = 0; i < packetLength; i++) {
        Serial.print("inData[");
        Serial.print(i);
        Serial.print("]: ");
        Serial.println(inData[i], HEX);
    }

    // Processo i dati ricevuti
    Serial.println("Pacchetto completo ricevuto, elaborazione dei dati...");
    uint16_t Propane = word(byte(inData[1]), byte(inData[0]));  // I primi 2 byte sono relativi al gas propano
    uint16_t CO_ppm = word(byte(inData[3]), byte(inData[2]));
    uint16_t flame = word(byte(inData[5]), byte(inData[4]));
    Serial.print("Propane: ");
    Serial.print(Propane);
    Serial.print(" ppm, CO: ");
    Serial.print(CO_ppm);
    Serial.print(" ppm, Flame: ");
    Serial.println(flame);

    if (packetLength > 6) {
        uint16_t Temperature = word(byte(inData[7]), byte(inData[6]));
        uint16_t humidity = word(byte(inData[9]), byte(inData[8]));
        Serial.print("Temperature: ");
        Serial.print(Temperature);   
        Serial.print(" C, humidity: ");
        Serial.print(humidity);
        Serial.println("%");
    }

    // Reset per il prossimo pacchetto
    started = false;
    ended = false;
    index = 0;
    packetLength = 0;  // Aggiungi questo reset per prevenire anomalie nei cicli successivi
}

  // Trasmissione di un ACK a telosB
  Tensione = analogRead(Tens_Pin);
  Transmit_Data[0] = Tensione & 0xff;
  Transmit_Data[1] = Tensione >> 8;

  mySerial.write(Transmit_Data,2);

  delay(1024);
}
